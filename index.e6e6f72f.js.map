{"mappings":"ACAA,IAAI,EACF,EACA,EACA,EAAU,EAAE,CACZ,EACA,EAkDF,SAAS,EAAI,CAAI,CAAE,CAAG,CAAE,CAAK,EAE3B,IAAI,EAAY,EAAM,SAAS,CAAC,AAAC,GAAO,IAAS,GAEjD,GAAI,AAAc,KAAd,EAAkB,CACpB,EAAM,MAAM,CAAC,EAAW,GACxB,EAAM,IAAI,CAAC,GACX,MACF,CAGA,IAAM,EAAiB,EAAI,OAAO,CAAC,MAEnC,GAAI,AAAmB,KAAnB,EAAuB,CACzB,EAAM,IAAI,CAAC,GACX,CAAG,CAAC,EAAe,CAAG,EACtB,MACF,CAIA,IAAM,EAAsB,EAAI,OAAO,CAAC,CAAK,CAAC,EAAE,CAChD,CAAA,CAAG,CAAC,EAAoB,CAAG,EAC3B,EAAM,KAAK,GACX,EAAM,IAAI,CAAC,EACb,CAEA,SAAS,EAAK,CAAI,CAAE,CAAG,CAAE,CAAK,EAE5B,GAAI,AAAsB,KAAtB,EAAI,OAAO,CAAC,GACd,OAIF,IAAM,EAAiB,EAAI,OAAO,CAAC,MAEnC,GAAI,AAAmB,KAAnB,EAAuB,CACzB,EAAM,IAAI,CAAC,GACX,CAAG,CAAC,EAAe,CAAG,EACtB,MACF,CAIA,IAAM,EAAsB,EAAI,OAAO,CAAC,CAAK,CAAC,EAAE,CAChD,CAAA,CAAG,CAAC,EAAoB,CAAG,EAC3B,EAAM,KAAK,GACX,EAAM,IAAI,CAAC,EACb,CAmDA,SAAS,IACP,EAAY,EACZ,EAAU,SAAS,CAAG,EACtB,EAAO,SAAS,CAAG,GACnB,EAAU,SAAS,CAAG,GACtB,EAAU,EAAE,CAEZ,IAAM,EAAM,EAAK,GAAG,CAAC,KAAK,CAAC,WAAW,GAAG,IAAI,GACvC,EAAU,EAAK,GAAG,CAAC,KAAK,CAAC,WAAW,GAAG,IAAI,GAC3C,EAAM,EAAK,KAAK,CAAC,KAAK,CACzB,IAAI,GACJ,KAAK,CAAC,KACN,GAAG,CAAC,AAAC,GAAM,CAAC,GAET,EAAM,AA3Cd,SAAwB,CAAI,EAC1B,IAAM,EAAM,EAAE,CAEd,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,IACxB,CAAG,CAAC,EAAE,CAAG,KAGX,OAAO,CACT,EAmC6B,GACrB,EAAQ,EAAE,CACV,EAAU,AAnClB,SAAkB,CAAG,EACnB,OAAQ,GACN,IAAK,OACH,OAAO,CACT,KAAK,MACH,OAAO,CACX,CAGF,EA0B2B,IAEzB,AA1BF,SAAsB,CAAG,EACvB,EAAI,OAAO,CAAC,AAAC,IACX,IAAM,EAAM,SAAS,aAAa,CAAC,KACnC,CAAA,EAAI,SAAS,CAAG,CAAC,IAAI,EAAE,EAAQ,KAAK,CAAC,CACrC,EAAU,MAAM,CAAC,EACnB,EACF,EAoBe,GAEb,IAAK,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAAK,CACnC,IAAM,EAAU,CAAC,CAAG,CAAC,EAAE,CAElB,EAGH,EAAQ,EAAS,EAAK,GAFtB,AA3KN,SAAa,CAAI,CAAE,CAAG,CAAE,CAAK,CAAE,CAAG,CAAE,CAAK,EAEvC,GAAI,AAAsB,KAAtB,EAAI,OAAO,CAAC,GACd,OAIF,IAAM,EAAiB,EAAI,OAAO,CAAC,MAEnC,GAAI,AAAmB,KAAnB,EAAuB,CACzB,EAAM,IAAI,CAAC,GACX,CAAG,CAAC,EAAe,CAAG,EACtB,MACF,CAIA,IAAM,EAAM,EAAE,CACV,EAAY,EAEhB,IAAK,IAAI,EAAI,EAAO,EAAI,EAAI,MAAM,CAAE,IASlC,GAPE,CAAG,CAAC,EAAE,GAAK,GACX,AAAyC,KAAzC,EAAI,SAAS,CAAC,AAAC,GAAO,IAAO,CAAG,CAAC,EAAE,GACnC,AAAyC,KAAzC,EAAI,SAAS,CAAC,AAAC,GAAO,IAAO,CAAG,CAAC,EAAE,GAEnC,EAAI,IAAI,CAAC,CAAG,CAAC,EAAE,EAGb,EAAI,MAAM,GAAK,EAAI,MAAM,CAAE,CAC7B,EAAY,EAAI,SAAS,CAAC,AAAC,GAAO,IAAO,CAAG,CAAC,EAAI,MAAM,CAAG,EAAE,EAC5D,KACF,CAGF,GAAI,EAAI,MAAM,GAAK,EAAI,MAAM,CAAE,CAC7B,CAAG,CAAC,EAAU,CAAG,EACjB,QAAQ,GAAG,CAAC,EAAK,GACjB,MACF,CAEA,IAAI,EAAI,EAAI,SAAS,CACnB,AAAC,GAAO,EAAI,MAAM,CAAC,AAAC,GAAO,AAAmC,KAAnC,EAAI,SAAS,CAAC,AAAC,GAAM,IAAO,GAAU,CAAC,EAAE,GAAK,EAG3E,CAAA,CAAG,CAAC,EAAE,CAAG,CACX,EA6HU,EAAS,EAAK,EAAO,EAAK,GAKhC,AA9EJ,SAAiB,CAAG,EAClB,IAAM,EAAM,SAAS,aAAa,CAAC,KAEnC,CAAA,EAAI,SAAS,CAAG,EACb,GAAG,CAAC,AAAC,IACJ,IAAI,EAAQ,AAA4C,KAA5C,EAAQ,SAAS,CAAC,AAAC,GAAM,IAAM,GAS3C,OAPgB,OAAZ,IACF,EAAU,GACV,EAAQ,CAAA,GAGN,CAAC,GAAO,IAEL,CAAC,WAAW,EAAE,EAAQ,GAAK,QAAQ,EAAE,EAAE,EAAQ,KAAK,CAAC,AAC9D,GACC,IAAI,CAAC,IACR,EAAO,MAAM,CAAC,EAChB,EA4DY,GACW,EAAf,AAAQ,QAAR,EAAyB,IAAI,EAAM,CACxB,IAAI,EAAI,AACzB,CAEA,EAAU,SAAS,CAAG,CACxB,CAEA,OAAO,gBAAgB,CAAC,OAAQ,KAC9B,EAAO,SAAS,aAAa,CAAC,SAC9B,EAAS,SAAS,aAAa,CAAC,WAChC,EAAY,SAAS,aAAa,CAAC,eACnC,EAAY,SAAS,aAAa,CAAC,eAEnC,IAEA,EAAK,gBAAgB,CAAC,SAAU,AAAC,IAC/B,EAAE,cAAc,GAChB,GACF,EACF","sources":["<anon>","src/index.js"],"sourcesContent":["var $35da740d59af89ba$exports = {};\nlet $35da740d59af89ba$var$form, $35da740d59af89ba$var$output, $35da740d59af89ba$var$outputSeq, $35da740d59af89ba$var$lastSeq = [], $35da740d59af89ba$var$brakStron, $35da740d59af89ba$var$stronData;\nfunction $35da740d59af89ba$var$opt(proc, mem, queue, seq, index) {\n    // if memory has such process, then do nothing\n    if (mem.indexOf(proc) !== -1) return;\n    // if memory has available space for this process, then we place this proces into the queue\n    const freeSpaceIndex = mem.indexOf(null);\n    if (freeSpaceIndex !== -1) {\n        queue.push(proc);\n        mem[freeSpaceIndex] = proc;\n        return;\n    }\n    // if memory has no free space and doesn't have this process, then we replace process in memory with this process\n    // OPT replacement\n    const arr = [];\n    let lastIndex = 0;\n    for(let i = index; i < seq.length; i++){\n        if (seq[i] !== proc && mem.findIndex((el)=>el === seq[i]) !== -1 && arr.findIndex((el)=>el === seq[i]) === -1) arr.push(seq[i]);\n        if (arr.length === mem.length) {\n            lastIndex = mem.findIndex((el)=>el === arr[arr.length - 1]);\n            break;\n        }\n    }\n    if (arr.length === mem.length) {\n        mem[lastIndex] = proc;\n        console.log(mem, arr);\n        return;\n    }\n    let i = mem.findIndex((el)=>mem.filter((el)=>arr.findIndex((e)=>el === e) === -1)[0] === el);\n    mem[i] = proc;\n}\nfunction $35da740d59af89ba$var$lru(proc, mem, queue) {\n    // if memory has such process, then do nothing\n    let procIndex = queue.findIndex((el)=>proc === el);\n    if (procIndex !== -1) {\n        queue.splice(procIndex, 1);\n        queue.push(proc);\n        return;\n    }\n    // if memory has available space for this process, then we place this proces into the queue\n    const freeSpaceIndex = mem.indexOf(null);\n    if (freeSpaceIndex !== -1) {\n        queue.push(proc);\n        mem[freeSpaceIndex] = proc;\n        return;\n    }\n    // if memory has no free space and doesn't have this process, then we replace process in memory with this process\n    // LRU replacement\n    const replaceElementIndex = mem.indexOf(queue[0]);\n    mem[replaceElementIndex] = proc;\n    queue.shift();\n    queue.push(proc);\n}\nfunction $35da740d59af89ba$var$fifo(proc, mem, queue) {\n    // if memory has such process, then do nothing\n    if (mem.indexOf(proc) !== -1) return;\n    // if memory has available space for this process, then we place this proces into the queue\n    const freeSpaceIndex = mem.indexOf(null);\n    if (freeSpaceIndex !== -1) {\n        queue.push(proc);\n        mem[freeSpaceIndex] = proc;\n        return;\n    }\n    // if memory has no free space and doesn't have this process, then we replace process in memory with this process\n    // FIFO replacement\n    const replaceElementIndex = mem.indexOf(queue[0]);\n    mem[replaceElementIndex] = proc;\n    queue.shift();\n    queue.push(proc);\n}\nfunction $35da740d59af89ba$var$drawMem(mem) {\n    const div = document.createElement(\"tr\");\n    div.innerHTML = mem.map((element)=>{\n        let isOld = $35da740d59af89ba$var$lastSeq.findIndex((e)=>e === element) !== -1;\n        if (element === null) {\n            element = \"\";\n            isOld = true;\n        }\n        if (!isOld) $35da740d59af89ba$var$brakStron++;\n        return `<td class=\"${isOld ? \"\" : \"isOld\"}\">${element}</td>`;\n    }).join(\"\");\n    $35da740d59af89ba$var$output.append(div);\n}\nfunction $35da740d59af89ba$var$allocateMemory(size) {\n    const arr = [];\n    for(let i = 0; i < size; i++)arr[i] = null;\n    return arr;\n}\nfunction $35da740d59af89ba$var$getAlgor(alg) {\n    switch(alg){\n        case \"fifo\":\n            return $35da740d59af89ba$var$fifo;\n        case \"lru\":\n            return $35da740d59af89ba$var$lru;\n    }\n    return undefined;\n}\nfunction $35da740d59af89ba$var$drawOuputSeq(seq) {\n    seq.forEach((element)=>{\n        const div = document.createElement(\"tr\");\n        div.innerHTML = `<td>${element}</td>`;\n        $35da740d59af89ba$var$outputSeq.append(div);\n    });\n}\nfunction $35da740d59af89ba$var$visualize() {\n    $35da740d59af89ba$var$brakStron = 0;\n    $35da740d59af89ba$var$stronData.innerText = $35da740d59af89ba$var$brakStron;\n    $35da740d59af89ba$var$output.innerHTML = \"\";\n    $35da740d59af89ba$var$outputSeq.innerHTML = \"\"; // Clear previous sequence\n    $35da740d59af89ba$var$lastSeq = [];\n    const alg = $35da740d59af89ba$var$form.alg.value.toLowerCase().trim();\n    const memSize = $35da740d59af89ba$var$form.mem.value.toLowerCase().trim();\n    const seq = $35da740d59af89ba$var$form.input.value.trim().split(\" \").map((e)=>+e);\n    const mem = $35da740d59af89ba$var$allocateMemory(memSize);\n    const queue = [];\n    const funcAlg = $35da740d59af89ba$var$getAlgor(alg);\n    $35da740d59af89ba$var$drawOuputSeq(seq);\n    for(let i = 0; i < seq.length; i++){\n        const element = +seq[i];\n        if (!funcAlg) $35da740d59af89ba$var$opt(element, mem, queue, seq, i);\n        else funcAlg(element, mem, queue);\n        $35da740d59af89ba$var$drawMem(mem);\n        if (alg !== \"opt\") $35da740d59af89ba$var$lastSeq = [\n            ...queue\n        ];\n        else $35da740d59af89ba$var$lastSeq = [\n            ...mem\n        ];\n    }\n    $35da740d59af89ba$var$stronData.innerText = $35da740d59af89ba$var$brakStron;\n}\nwindow.addEventListener(\"load\", ()=>{\n    $35da740d59af89ba$var$form = document.querySelector(\".form\");\n    $35da740d59af89ba$var$output = document.querySelector(\".output\");\n    $35da740d59af89ba$var$stronData = document.querySelector(\".stron-data\");\n    $35da740d59af89ba$var$outputSeq = document.querySelector(\".output-seq\");\n    $35da740d59af89ba$var$visualize();\n    $35da740d59af89ba$var$form.addEventListener(\"submit\", (e)=>{\n        e.preventDefault();\n        $35da740d59af89ba$var$visualize();\n    });\n});\n\n\n//# sourceMappingURL=index.e6e6f72f.js.map\n","let form,\n  output,\n  outputSeq,\n  lastSeq = [],\n  brakStron,\n  stronData;\n\nfunction opt(proc, mem, queue, seq, index) {\n  // if memory has such process, then do nothing\n  if (mem.indexOf(proc) !== -1) {\n    return;\n  }\n\n  // if memory has available space for this process, then we place this proces into the queue\n  const freeSpaceIndex = mem.indexOf(null);\n\n  if (freeSpaceIndex !== -1) {\n    queue.push(proc);\n    mem[freeSpaceIndex] = proc;\n    return;\n  }\n\n  // if memory has no free space and doesn't have this process, then we replace process in memory with this process\n  // OPT replacement\n  const arr = [];\n  let lastIndex = 0;\n\n  for (let i = index; i < seq.length; i++) {\n    if (\n      seq[i] !== proc &&\n      mem.findIndex((el) => el === seq[i]) !== -1 &&\n      arr.findIndex((el) => el === seq[i]) === -1\n    ) {\n      arr.push(seq[i]);\n    }\n\n    if (arr.length === mem.length) {\n      lastIndex = mem.findIndex((el) => el === arr[arr.length - 1]);\n      break;\n    }\n  }\n\n  if (arr.length === mem.length) {\n    mem[lastIndex] = proc;\n    console.log(mem, arr);\n    return;\n  }\n\n  let i = mem.findIndex(\n    (el) => mem.filter((el) => arr.findIndex((e) => el === e) === -1)[0] === el\n  );\n    \n  mem[i] = proc;\n}\n\nfunction lru(proc, mem, queue) {\n  // if memory has such process, then do nothing\n  let procIndex = queue.findIndex((el) => proc === el);\n\n  if (procIndex !== -1) {\n    queue.splice(procIndex, 1);\n    queue.push(proc);\n    return;\n  }\n\n  // if memory has available space for this process, then we place this proces into the queue\n  const freeSpaceIndex = mem.indexOf(null);\n\n  if (freeSpaceIndex !== -1) {\n    queue.push(proc);\n    mem[freeSpaceIndex] = proc;\n    return;\n  }\n\n  // if memory has no free space and doesn't have this process, then we replace process in memory with this process\n  // LRU replacement\n  const replaceElementIndex = mem.indexOf(queue[0]);\n  mem[replaceElementIndex] = proc;\n  queue.shift();\n  queue.push(proc);\n}\n\nfunction fifo(proc, mem, queue) {\n  // if memory has such process, then do nothing\n  if (mem.indexOf(proc) !== -1) {\n    return;\n  }\n\n  // if memory has available space for this process, then we place this proces into the queue\n  const freeSpaceIndex = mem.indexOf(null);\n\n  if (freeSpaceIndex !== -1) {\n    queue.push(proc);\n    mem[freeSpaceIndex] = proc;\n    return;\n  }\n\n  // if memory has no free space and doesn't have this process, then we replace process in memory with this process\n  // FIFO replacement\n  const replaceElementIndex = mem.indexOf(queue[0]);\n  mem[replaceElementIndex] = proc;\n  queue.shift();\n  queue.push(proc);\n}\n\nfunction drawMem(mem) {\n  const div = document.createElement(\"tr\");\n\n  div.innerHTML = mem\n    .map((element) => {\n      let isOld = lastSeq.findIndex((e) => e === element) !== -1;\n\n      if (element === null) {\n        element = \"\";\n        isOld = true;\n      }\n\n      if (!isOld) brakStron++;\n\n      return `<td class=\"${isOld ? \"\" : \"isOld\"}\">${element}</td>`;\n    })\n    .join(\"\");\n  output.append(div);\n}\n\nfunction allocateMemory(size) {\n  const arr = [];\n\n  for (let i = 0; i < size; i++) {\n    arr[i] = null;\n  }\n\n  return arr;\n}\n\nfunction getAlgor(alg) {\n  switch (alg) {\n    case \"fifo\":\n      return fifo;\n    case \"lru\":\n      return lru;\n  }\n\n  return undefined;\n}\n\nfunction drawOuputSeq(seq) {\n  seq.forEach((element) => {\n    const div = document.createElement(\"tr\");\n    div.innerHTML = `<td>${element}</td>`;\n    outputSeq.append(div);\n  });\n}\n\nfunction visualize() {\n  brakStron = 0;\n  stronData.innerText = brakStron;\n  output.innerHTML = \"\";\n  outputSeq.innerHTML = \"\"; // Clear previous sequence\n  lastSeq = [];\n\n  const alg = form.alg.value.toLowerCase().trim();\n  const memSize = form.mem.value.toLowerCase().trim();\n  const seq = form.input.value\n    .trim()\n    .split(\" \")\n    .map((e) => +e);\n\n  const mem = allocateMemory(memSize);\n  const queue = [];\n  const funcAlg = getAlgor(alg);\n\n  drawOuputSeq(seq);\n\n  for (let i = 0; i < seq.length; i++) {\n    const element = +seq[i];\n\n    if (!funcAlg) {\n      opt(element, mem, queue, seq, i);\n    } else {\n      funcAlg(element, mem, queue);\n    }\n\n    drawMem(mem);\n    if (alg !== \"opt\") lastSeq = [...queue];\n    else lastSeq = [...mem];\n  }\n\n  stronData.innerText = brakStron;\n}\n\nwindow.addEventListener(\"load\", () => {\n  form = document.querySelector(\".form\");\n  output = document.querySelector(\".output\");\n  stronData = document.querySelector(\".stron-data\");\n  outputSeq = document.querySelector(\".output-seq\");\n\n  visualize();\n\n  form.addEventListener(\"submit\", (e) => {\n    e.preventDefault();\n    visualize();\n  });\n});\n"],"names":["$35da740d59af89ba$var$form","$35da740d59af89ba$var$output","$35da740d59af89ba$var$outputSeq","$35da740d59af89ba$var$lastSeq","$35da740d59af89ba$var$brakStron","$35da740d59af89ba$var$stronData","$35da740d59af89ba$var$lru","proc","mem","queue","procIndex","findIndex","el","splice","push","freeSpaceIndex","indexOf","replaceElementIndex","shift","$35da740d59af89ba$var$fifo","$35da740d59af89ba$var$visualize","innerText","innerHTML","alg","value","toLowerCase","trim","memSize","seq","input","split","map","e","$35da740d59af89ba$var$allocateMemory","size","arr","i","funcAlg","$35da740d59af89ba$var$getAlgor","$35da740d59af89ba$var$drawOuputSeq","forEach","element","div","document","createElement","append","length","$35da740d59af89ba$var$opt","index","lastIndex","console","log","filter","$35da740d59af89ba$var$drawMem","isOld","join","window","addEventListener","querySelector","preventDefault"],"version":3,"file":"index.e6e6f72f.js.map"}